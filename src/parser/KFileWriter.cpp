#include "parser/KFileWriter.h"
#include <sstream>
#include <iomanip>
#include <ctime>
#include <algorithm>

namespace KooRemapper {

KFileWriter::KFileWriter()
    : precision_(9)
    , coordFieldWidth_(16)
    , includeHeader_(true)
{}

bool KFileWriter::writeFile(const std::string& filename, const Mesh& mesh,
                            bool useMappedPositions) {
    errorMessage_.clear();

    std::ofstream file(filename);
    if (!file.is_open()) {
        errorMessage_ = "Cannot create file: " + filename;
        return false;
    }

    try {
        if (includeHeader_) {
            writeHeader(file);
        }

        writeNodeSection(file, mesh, useMappedPositions);
        writeElementSection(file, mesh);
        writeEnd(file);

        file.close();
        return true;
    }
    catch (const std::exception& e) {
        errorMessage_ = std::string("Error writing file: ") + e.what();
        file.close();
        return false;
    }
}

void KFileWriter::writeHeader(std::ofstream& file) {
    // Get current time
    std::time_t now = std::time(nullptr);
    char timeStr[64];
    std::strftime(timeStr, sizeof(timeStr), "%Y-%m-%d %H:%M:%S", std::localtime(&now));

    file << "$" << std::endl;
    file << "$ LS-DYNA Keyword File" << std::endl;
    file << "$ Generated by KooRemapper" << std::endl;
    file << "$ Date: " << timeStr << std::endl;
    file << "$" << std::endl;
}

void KFileWriter::writeNodeSection(std::ofstream& file, const Mesh& mesh,
                                   bool useMappedPositions) {
    file << "*NODE" << std::endl;
    file << "$#   nid               x               y               z" << std::endl;

    // Sort nodes by ID for consistent output
    std::vector<std::pair<int, const Node*>> sortedNodes;
    for (const auto& [id, node] : mesh.nodes) {
        sortedNodes.push_back({id, &node});
    }
    std::sort(sortedNodes.begin(), sortedNodes.end(),
              [](const auto& a, const auto& b) { return a.first < b.first; });

    for (const auto& [id, nodePtr] : sortedNodes) {
        const Node& node = *nodePtr;
        const Vector3D& pos = useMappedPositions && node.isMapped
                            ? node.mappedPosition
                            : node.position;

        file << std::setw(8) << node.id
             << formatDouble(pos.x)
             << formatDouble(pos.y)
             << formatDouble(pos.z)
             << std::endl;
    }
}

void KFileWriter::writeElementSection(std::ofstream& file, const Mesh& mesh) {
    file << "*ELEMENT_SOLID" << std::endl;
    file << "$#   eid     pid      n1      n2      n3      n4      n5      n6      n7      n8" << std::endl;

    // Sort elements by ID
    std::vector<std::pair<int, const Element*>> sortedElements;
    for (const auto& [id, elem] : mesh.elements) {
        sortedElements.push_back({id, &elem});
    }
    std::sort(sortedElements.begin(), sortedElements.end(),
              [](const auto& a, const auto& b) { return a.first < b.first; });

    for (const auto& [id, elemPtr] : sortedElements) {
        const Element& elem = *elemPtr;

        file << std::setw(8) << elem.id
             << std::setw(8) << elem.partId;

        if (elem.type == ElementType::TET4) {
            // TET4: write 4 nodes, then repeat n4 for n5-n8 (LS-DYNA convention)
            for (int i = 0; i < 4; ++i) {
                file << std::setw(8) << elem.nodeIds[i];
            }
            for (int i = 4; i < 8; ++i) {
                file << std::setw(8) << elem.nodeIds[3];  // Repeat n4
            }
        } else {
            // HEX8 and others: write all 8 nodes
            for (int i = 0; i < Element::NUM_NODES; ++i) {
                file << std::setw(8) << elem.nodeIds[i];
            }
        }
        file << std::endl;
    }
}

void KFileWriter::writeEnd(std::ofstream& file) {
    file << "*END" << std::endl;
}

std::string KFileWriter::formatDouble(double value) const {
    std::ostringstream oss;
    oss << std::setw(coordFieldWidth_)
        << std::scientific
        << std::setprecision(precision_)
        << value;
    return oss.str();
}

std::string KFileWriter::formatInt(int value, int width) const {
    std::ostringstream oss;
    oss << std::setw(width) << value;
    return oss.str();
}

} // namespace KooRemapper
